# Branch Infrastructure
    # 其实不管 本地分支 还是 远程分支 都是保存在 本地的，当 fetch 的时候，会根据远程库 更新 本地对应远程库的分支
    master          # 主分支，仓库创建时自动创建的分支名
    HEAD            # 表示当前所在分支的别名
    
    
# Remote Branch Manager
    shell> git branch -a -vv                # 查看当前 git 仓库所有分支
    shell> git branch -r                    # 查看当前 git 仓库所有远程分支
    
    # 创建远程分支
        shell> git branch localBranch           # 先创建 本地分支
        shell> git push origin localBranch:     # 将本地分支 push 到远程库
    
    # 分支关联
        shell> git branch --set-upstream-to=origin/master debug        # 设置本地库 debug 分支关联的远程库分支
        shell> git branch --unset-upstream debug            # 取消本地库 debug 分支关联的远程库分支
        
        shell> git branch --track localBranch origin/remoteBranch       # 跟踪远程分支
    
    # 删除远程分支
        shell> git branch -r -d origin/debug        # 删除本地库中的 远程分支  
        shell> git push origin :debug               # 将删除的远程分支 push 到远程仓库

# Local Branch Manager
    # 查看所有分支
        shell> git branch -vv                   # 查看当前 git 仓库所有本地分支
        shell> git branch --list 'regexp'       # 列出所有符合 正则表达式 的分支
        shell> git branch --merged              # 查看所有已合并的分支，可以删除
        shell> git branch --no-merged           # 查看所有未合并的分支
    
    # 分支创建
    shell> git branch debug                  # 创建一个 debug 分支
    
    # 分支删除
    shell> git branch -d debug              # 删除当前分支上的 debug 分支
    shell> git branch -D debug              # 强制删除 debug 分支
    
    
    # 分支切换
    shell> git checkout debug               # 切换到当前分支上的 debug 分支

    # 分支合并
    shell> git checkout master              # 切换到 master 分支上
    shell> git merge debug                  # 把 debug 分支更新合并到当前(master)分支上
    shell> git status                       # 如果出现分支合并冲突，使用该命令查看冲突的文件
    shell> vim conflict.txt                 # 打开冲突的文件，找到文件中如下格式的字符串，并手工处理冲突
                                            # <<<<<<< HEAD
                                            # HEAD(master) 分支修改的内容
                                            # =======
                                            # debug 分支修改的内容
                                            # >>>>>>> branch2
                                            
    shell> git add conflict.txt             # 手工处理完冲突后，再把冲突文件手工提交到缓存区，表示冲突已解决，再提交即可
    shell> git commit -m '分支合并，冲突处理后提交'
    shell> git log --oneline --decorate --graph --all   # 查看分支情况
    
    # 高级合并
    shell> git merge --abort                # 放弃当前合并
    shell> git reset --hard HEAD            # 回到之前的状态
    shell> git merge -Xignore-all-space debug           # 忽略所有空白
    shell> git merge -Xignore-space-change debug        # 忽略所有空白的修改
    
    # 手工合并文件
    # 坑：merge 提交前执行以下命令才有效
    shell> git show :1:hello.rb > hello.common.rb       # 共同 ancestor 节点保存的文件版本 输出重定向到 hello.common.rb 用于手工处理冲突
    shell> git show :2:hello.rb > hello.ours.rb         # 当前合并分支保存的文件版本
    shell> git show :3:hello.rb > hello.theirs.rb       # 被合并分支保存的文件版本
    
    shell> git ls-files -u              # 更底层的方式查看冲突的文件
    shell> git merge-file -p hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb             # 合并文件
    
    shell> git checkout --conflict=diff3 hello.rb
    shell> git checkout --ours              # 直接选择当前分支的版本作为合并后的版本，抛弃另一个版本
    shell> git checkout --theirs            # 直接选择合并分支的版本作为合并标准，抛弃当前分支的版本

    
    
    # 查看合并对各版本文件内容造成的影响
    shell> git diff --ours                  # 查看分支合并到底引入了哪些东西
    shell> git diff --theirs                # 查看分支合并，对被合并分支版本做了哪些修改
    shell> git diff --base                  # 查看分支合并，对两个分支否版本的修改
    
    # 合并清理
    shell> git clean -f                     # 清理为手动合并而创建但不再有用的额外文件
    
    
    # 撤销合并
    shell> git reset            # 直接将 HEAD 指针往老 commit 移动，抛弃新的 commit
    shell> git revert           # 新建一个 commit 用老数据覆盖最新修改的数据
    
    
    shell> git reset --hard HEAD~           # 有风险，会丢失合并节点之后的提交
    shell> git revert -m 1 HEAD             # 还原提交
    shell> git revert ^M                    # 撤销 原来的 还原操作
    

        

    
        
    
        
         

